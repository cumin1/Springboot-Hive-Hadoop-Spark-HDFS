<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<title>奇异值分解计算与应用</title>
		<link rel="stylesheet" type="text/css" href="css/bootstrap.css"/>
		<link rel="stylesheet" type="text/css" href="css/link1.css"/>
		<script id="MathJax-script" async src="../js/es5/tex-chtml.js"></script>
		<script>
		MathJax = {
		  tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
		};
		</script>
	</head>
	<body class="container-fluid">		
		<h2 class="my-5 hnav">奇异值分解计算与应用</h2>
		<div id="right_nav">
			<ul>
				<li class="active">知识</li>
				<li>实训</li>
				<li>扩展</li>
				<li class='last'>顶部</li>
			</ul>
		</div>
		<h3 class="mb-3 son_wrap" id='knowledge'>一、知识</h3>		
		<ol>
			<li>
				<h5>奇异值分解（SVM）<span class="ktitle ml-5 badge badge-light badge-pill">show more</span></h5>
				<div class="kdetails">
					<p class="mt-3">对一个$m \times n$矩阵$A_{m \times n}$来说，其SVD分解公式为：$$A_{m \times n}=U_{m \times n}\Sigma_{m \times n}V_{n \times n}$$简记为：$$A=U \Sigma V$$其中，$U$、$V$是正交矩阵（酉矩阵），意为$U^TU=E_{m \times m}，V^TV=E_{n \times n}$。</p>
					<p>$U$矩阵，称为$A$的左奇异矩阵，其列由$AA^T$的特征向量组成，且特征向量为单位向量，包含了行的重要信息。</p>
					<p>$V$矩阵，称为$A$的右奇异矩阵，其列由$A^TA$的特征向量组成，且特征向量为单位向量，包含了列的重要信息。</p>
					<p>$\Sigma$矩阵，称为$A$的奇异值矩阵，其对角元素是$AA^T$或$A^TA$的特征值的平方根，按从大到小排列。</p>
					<p><b>任务：</b>利用NumPy中的linalg工具箱的svd()函数对下列矩阵进行奇异值分解。</p>
					<p><b>小贴士：s</b>vd()函数格式为：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;svd(A, full_matrices=1,compute_uv=1)<br>返回值：$u$、$s$和$v$分别对应$U$矩阵，奇异值和$V$的转置矩阵$V^T$。</p>
					<p>参数含义为：$A$是一个$M \times N$阶矩阵；Full_matrices的取值为0或-1。默认值为1时，返回值$u$的大小为$(M,M)$，返回值$v$的大小为$(N,N)$；值为0时，$u$的大小为$(M,K)$，$v$的大小为$(K,N)$，$K=min(M,N)$。$$A=\begin{bmatrix}
1 & 2 & 3 & 4 & 5\\
2 & 3 & 4 & 5 & 1\\
3 & 4 & 5 & 1 & 2
\end{bmatrix}$$</p>
					<p><kbd>Step1</kbd>&nbsp;&nbsp;导入库</p>
					<p class="p-code">
						<code>import numpy as np<br>from numpy import linalg as la</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
					</p>
					<p><kbd>Step2</kbd>&nbsp;&nbsp;构造矩阵</p>
					<p class="p-code">
						<code>A=np.mat([[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7]])</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
					</p>
					<p><kbd>Step3</kbd>&nbsp;&nbsp;调用SVD函数</p>
					<p class="p-code">
						<code>U,s,V_T=la.svd(A)</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
					</p>
					<p><kbd>Step4</kbd>&nbsp;&nbsp;生成奇异值矩阵$\Sigma$、显示左奇异矩阵$U$和右奇异矩阵转置$V^T$</p>
					<p class="p-code">
						<code>print("左奇异值矩阵：\n",U)<br>print("奇异值：",s)<br>#diag()函数只能构造方阵<br>#sigma=np.diag(s)<br>#创建一个与A同样大小的零矩阵<br>sigma=np.zeros(np.shape(A))<br>#生成奇异值矩阵<br>sigma[:len(s),:len(s)]=np.diag(s)<br>print("奇异值矩阵：\n",sigma)<br>print("右奇异值矩阵转置：\n",V_T)</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
					</p>
					<div>Out: 左奇异值矩阵：
					<p class="p-code">[[-0.44127483  0.79913069  0.40824829]<br>[-0.56800242  0.10347264 -0.81649658]<br> [-0.69473    -0.59218541  0.40824829]]<br>奇异值： [1.67010311e+01 1.03709214e+00 9.14681404e-16]<br>奇异值矩阵：<br> [[1.67010311e+01 0.00000000e+00 0.00000000e+00 0.00000000e+00  0.00000000e+00]<br> [0.00000000e+00 1.03709214e+00 0.00000000e+00 0.00000000e+00  0.00000000e+00]<br>
 [0.00000000e+00 0.00000000e+00 9.14681404e-16 0.00000000e+00  0.00000000e+00]]<br>右奇异值矩阵转置：<br>
 [[-0.21923614 -0.32126621 -0.42329627 -0.52532633 -0.6273564 ]<br>
 [-0.74292363 -0.44360796 -0.1442923   0.15502336  0.45433903]<br>
 [ 0.62702762 -0.65909334 -0.31848012  0.10612977  0.24441607]<br>
 [-0.06507662  0.17578258 -0.51267914  0.75831701 -0.35634383]<br>
 [ 0.05100386  0.4844548  -0.66009887 -0.33718212  0.46182232]]</p>
					</div>
					<p><kbd>Step5</kbd>&nbsp;&nbsp重构矩阵</p>
					<p class="p-code">我们可以svd()函数分解的结果$U$、$\Sigma$和$V^T$重构原始矩阵。<br><code> #还原<br>A_reconstructed=U.dot(sigma).dot(V_T)<br>print("重构矩阵：\n",A_reconstructed)</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
					</p>
					<div>Out: 重构矩阵：
						<p class="p-code">[[1. 2. 3. 4. 5.]<br>[2. 3. 4. 5. 6.]<br>[3. 4. 5. 6. 7.]]</p>					
					</div>
				</div>
			</li>
			<li>
				<h5>SVD数据压缩<span class="ktitle ml-5 badge badge-light badge-pill">show more</span></h5>				
				<div class="kdetails">
					<p>上例中，SVD得到的奇异特征值个数$k=3$，其中前两项较大，最后一项值较小。通过取不同的$k$值，分别对应于$U$的前$k$列，$\Sigma$变成$k$阶方阵，$V^T$取前$k$行，对比利用矩阵乘积得到的新矩阵与原始矩阵的近似程度。</p>
					<p><b>任务：</b>选择重要的特征值重构矩阵，以达到降维的目的。</p>
					<p class="p-code">
						<code>#U[:,:k]代表前k列，sigma[:k,:k]代表k阶方阵，V_T[:k,:]代表k行<br>for k in range(3,0,-1):<br>&nbsp;&nbsp;A_reconstructed=U[:,:k].dot(sigma[:k,:k].dot(V_T[:k,:]))<br>&nbsp;&nbsp;print("k=",k,"压缩后矩阵：\n",A_reconstructed)</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
					</p>
					<div>Out: k= 3 压缩后矩阵：</div>
					<p class="p-code">[[1. 2. 3. 4. 5.]<br> [2. 3. 4. 5. 6.]<br> [3. 4. 5. 6. 7.]]<br>k= 2 压缩后矩阵：<br> [[1. 2. 3. 4. 5.]<br> [2. 3. 4. 5. 6.]<br> [3. 4. 5. 6. 7.]]<br />k= 1 压缩后矩阵：<br> [[1.61571441 2.36764993 3.11958544 3.87152095 4.62345646]<br>[2.07972363 3.04760386 4.0154841  4.98336434 5.95124458]<br> [2.54373284 3.7275578  4.91138277 6.09520773 7.27903269]]</p>
					<div><b>结论：</b>以上表明，奇异特征值取前2个较大特征值，舍弃1个小的，重构后的矩阵与原始矩阵一样，几乎没有任何损失；若取前1个最大特征值，舍弃2个小的，重构后的矩阵保留了原始矩阵大部分。这样通过选取适当的个数特征值，既保留了绝大部分原始信息，也减少了存储空间和计算时间，实现通过对数据的近似以达到压缩、降维、去噪和消冗的目的。$$A_{m \times n}=U_{m \times k}\Sigma_{k \times k}V_{n \times n}(k<< \min(m,n))$$<br>其几何示意如图1所示。
					</div>
					<div class="row mb-3">
						<div class="col text-center">
							<img src="img/1-5-1.png" class="img-fluid">
							<div class="small">图1&nbsp;&nbsp;&nbsp;&nbsp;SVD近似的几何表示</div>
						</div>
					</div>
				</div>									
			</li>			
		</ol>
		<h3 class="mt-5 mb-3 son_wrap" id="training">二、实训</h3>
		<h6><b class="task">任务：</b>运用SVD算法对图像进行降维处理，希望用更少的像素表示原图像（图2），实现图像分解、压缩、重构、再现图像。</h6>
		<div class="row mb-3">
			<div class="col text-center">
				<img src="img/1-5-2.jpg" class="img-fluid">
				<div class="small">图2&nbsp;&nbsp;&nbsp;&nbsp;原始图像ZFX.jpg</div>
			</div>
		</div>			
		<div><b>要求：</b>请用Python实现。</div>		
		<p><kbd>Step1</kbd>&nbsp;&nbsp;导入库</p>
		<p class="p-code">
			<code>#导入numpy库<br/>import numpy as np<br>#导入svd()模块<br />from numpy.linalg import svd<br>from PIL import Image<br>import matplotlib.pyplot as plt</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
		</p>
		<p><kbd>Step2</kbd>&nbsp;&nbsp;读取图像，一个图像是RGB三个颜色通道的叠加，通过plt.imread()函数得到一个行数╳列数╳3维数组，将图像像素分解成3个矩阵，分别为R、G、B图层，然后对这3个图层进行处理。</p>
		<p class="p-code">
		<code>path = r'C:\users\hu\desktop\人工智能数学基础及应用\data\lenna.jpg'<br>#读取图像<br>image = Image.open(path)<br>#生成矩阵<br>
image = np.array(image)<br>#显示矩阵大小<br>print(np.shape(image))<br>#显示原始图像<br>plt.imshow(image)</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
		</p>
		<p><kbd>Step3</kbd>&nbsp;&nbsp;自定义函数，按照指定的特征值个数，对3个图层分别进行SVD分解、压缩，将压缩后的3个矩阵叠加起来，重构图像。</p>
		<p class="p-code">
			<code># 保留前 k 个奇异值<br>#根据特征值个数压缩图像<br>def compression(image, k):<br>&nbsp;&nbsp;&nbsp;&nbsp;image2 = np.zeros_like(image)<br>&nbsp;&nbsp;&nbsp;&nbsp;#提取R、G、B三个分层图像的矩阵<br>&nbsp;&nbsp;&nbsp;&nbsp;for i in range(image.shape[2]):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#SVD分解<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;U, S, V_T = svd(image[:,:,i])<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#SVD逆运算、重构图像<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;image2[:,:,i] = U[:,:k].dot(np.diag(S[:k])).dot(V_T[:k,:])<br>&nbsp;&nbsp;&nbsp;&nbsp;#显示图像<br>&nbsp;&nbsp;&nbsp;&nbsp;plt.imshow(image2)<br>&nbsp;&nbsp;&nbsp;&nbsp;#标题<br>&nbsp;&nbsp;&nbsp;&nbsp;plt.title('k = %s' % k)</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
		</p>
		<p><kbd>Step4</kbd>&nbsp;&nbsp;显示图像</p>
		<p class="p-code">
			<code>#画布大小<br>plt.figure(figsize=(20,10))<br>#图像矩阵行数的一半<br>k = image.shape[0]/2<br>for i in range(8):<br>&nbsp;&nbsp;&nbsp;&nbsp;#特征值个数取半<br>&nbsp;&nbsp;&nbsp;&nbsp;k = int(k/2)<br>&nbsp;&nbsp;&nbsp;&nbsp;#画布位置<br>&nbsp;&nbsp;&nbsp;&nbsp;pos = 241+i<br>&nbsp;&nbsp;&nbsp;&nbsp;#建立子图<br>&nbsp;&nbsp;&nbsp;&nbsp;plt.subplot(pos)<br>&nbsp;&nbsp;&nbsp;&nbsp;#调用压缩函数<br>&nbsp;&nbsp;&nbsp;&nbsp;compression(image, k)</code>&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" class="btn btn-sm btn-primary copyBtn">复制</button>
		</p>		
		<div><b>Out:</b>(1440, 1080, 3)</div>
		<div class="container-fluid text-center"><img src="img/1-5-3.png" class="img-fluid"></div>		
		<h3 id="extend" class="son_wrap mt-5">三、扩展</h3>
		<p><b class="task">任务：</b>在上述实训项目中，K值的选取是人为设定的，如何科学方法确定K值呢？</p>
		<p>假设SVD分解式$A=U\Sigma V$中$\Sigma$的特征值为$\lambda_1,\lambda_2,\cdots,\lambda_n(n \le m)$，我们设置一个阈值，例如$t=80$%，然后选取使下式成立的最小$k$值：$$\frac{\sum_{i=1}^{k}\lambda_i}{\sum_{i=1}^{n}\lambda_i}\ge t$$修改上述代码，根据上式确定K值，然后分解、重构图像。
&nbsp;&nbsp;&nbsp;&nbsp;<button class="btn btn-sm btn-success" id='tips'>点击查看答案</button></p>		
		<div class="answer">Python代码：
			<p><kbd>Step1</kbd>&nbsp;&nbsp;导入库</p>
			<p class="p-code">
				<code>import numpy as np<br>#导入svd()模块<br>from numpy.linalg import svd<br>from PIL import Image<br>import matplotlib.pyplot as plt</code>
			</p>
			<p><kbd>Step2</kbd>&nbsp;&nbsp;读取图像，一个图像是RGB三个颜色通道的叠加，通过plt.imread()函数得到一个行数╳列数╳3维数组，将图像像素分解成3个矩阵，分别为R、G、B图层，然后对这3个图层进行处理。</p>
			<p class="p-code">
				<code># 文件路径<br>path = r'C:\users\hu\desktop\人工智能数学基础及应用\data\lenna.jpg'<br>#读取图像<br>image = Image.open(path)<br>#生成矩阵<br>image = np.array(image)<br>#显示矩阵大小<br>print(np.shape(image))<br>#显示原始图像<br>plt.imshow(image)</code>
			</p>
			<p><kbd>Step3</kbd>&nbsp;&nbsp;按预先设置的占比求k值，对3个图层分别进行SVD分解、压缩，将压缩后的3个矩阵叠加起来，重构图像。</p>
			<p class="p-code">
				<code>#阈值，即前k个特征值之和与总的特征值之和的比为80%<br>t=0.8<br>#生成与原始图像一样大小的新3维矩阵<br>image2 = np.zeros_like(image)<br>#提取R、G、B三个分层图像的矩阵<br>for i in range(image.shape[2]):<br>&nbsp;&nbsp;#SVD分解<br>&nbsp;&nbsp;U, S, V_T = svd(image[:,:,i])<br>&nbsp;&nbsp;#每层图像分解之后的特征值之和<br>&nbsp;&nbsp;Total=sum(S)<br>&nbsp;&nbsp;#前k个特征值之和的初始值设为0，k值的初值设为1<br>&nbsp;&nbsp;s=0;k=1<br>&nbsp;&nbsp;#求k值，使前k个特征值之和占总和的80%<br>&nbsp;&nbsp;for j in range(len(S)-1):<br>&nbsp;&nbsp;&nbsp;&nbsp;s=s+S[j]<br>&nbsp;&nbsp;&nbsp;&nbsp;if s&lt;Total*t:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k=k+1<br>&nbsp;&nbsp;&nbsp;&nbsp;else:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br>&nbsp;&nbsp;#SVD逆运算、重构图像<br>&nbsp;&nbsp;image2[:,:,i] = U[:,:k].dot(np.diag(S[:k])).dot(V_T[:k,:])</code>
			</p>
			<p><kbd>Step4</kbd>&nbsp;&nbsp;显示图像</p>
			<p class="p-code">
				<code>#画布大小<br>plt.figure(figsize=(20,10))<br>plt.imshow(image2)<br>#标题<br>plt.title('k = %s' % k)</code>
			</p>
			<p><kbd>Step5</kbd>&nbsp;&nbsp;输出结果</p>
			<p class="p-code">
				<code>Text(0.5, 1.0, 'k = 207')</code>
			</p>
			<div><b>Out：</b></div>
			<div class="container-fluid"><img src="img/1-5-4.jpg" class="img-fluid"><br><img src="img/1-5-5.jpg" class="img-fluid"></div>
		</div>
		<div class="program" draggable="true">
			<div class="pro-text card bg-light">
				<form>
					<h3 class="card-title">程序调试<button type="button" class="close"><span>&times;</span></button></h3>
					<textarea id='pro'></textarea><br/>
					<div class="card-footer">
						<input type="submit" value="运行程序" class="btn btn-info"/>
						<input type="reset" name="" id="pro-clear" value="清空" class="btn btn-warning"/>
					</div>					
				</form>
			</div>
			<div id='pro-result'>
				此处显示运行结果
			</div>
		</div>
		<script src="../js/jquery-3.4.1.min.js" type="text/javascript" charset="utf-8"></script>
		<script src="../js/bootstrap.bundle.min.js" type="text/javascript" charset="utf-8"></script>
		<script src="../js/link.js" type="text/javascript" charset="utf-8"></script>
	</body>
</html>
